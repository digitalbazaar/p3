/*
 * Copyright (c) 2012-2014 Digital Bazaar, Inc. All rights reserved.
 */
var async = require('async');
var bedrock = require('bedrock');
var jsonld = require('./jsonld'); // use locally-configured jsonld
var payswarm = {
  logger: bedrock.loggers.get('app'),
  money: require('./money'),
  tools: require('./tools')
};
var Money = payswarm.money.Money;
var BedrockError = bedrock.util.BedrockError;

// constants
var MODULE_TYPE = 'payswarm.paymentGateway';

// test payment gateway module API
var api = {};
api.name = MODULE_TYPE + '.Test';
api.gatewayName = 'Test';
api.authorityOnly = false;
module.exports = api;

/**
 * This TestGateway is used as a mock card gateway. Specific responses
 * can be generated by using the input data below.
 *
 * If you would like to make a successful deposit using this Test Gateway,
 * use the following information:
 *
 * ZIP: 11111
 * Card Type: Visa
 * Card Number: 4111111111111111
 * Month: Any
 * Year: Any
 * CVM: 999
 * Amount: Anything >= $1
 *
 * Note: Care must be taken not to use this gateway in a live environment!
 *
 * Valid card numbers follow. All others are invalid.
 *
 * Visa       4111111111111111
 * MasterCard 5499740000000057
 * Discover   6011000991001201
 * Amex       371449635392376
 * Diners     38555565010005
 * Diners/MC  36050000000003
 * JCB        3530142019955809
 *
 * Standard Card Transactions
 * Amount   Response
 * $0.00    13 Invalid Amount
 * 0.69     51 Insufficient funds
 * 0.95     5  Do not honor
 *
 * $10.00   00 Approval
 * $32.49   00 Approval (with approval code of 'A')
 *
 * Card Verification Value Test Responses
 * CVV2 Response
 * 999 (Visa)  M
 * 998 (MasterCard)  M
 * 996 (Discover) M
 * 996 (Diners)   M
 * 000 (Any) N
 * 899 (Visa)  U
 * 898 (MasterCard)  U
 * 896 (Discover)  U
 * 799 (Visa) P
 * 798 (MasterCard) P
 * 796 (Discover) P
 * 699 (Visa) S
 * 698 (MasterCard) S
 * 696 (Discover) S
 *
 * Address Verification Service Responses
 * Only Zip Code field used, other address fields ignored.
 *
 * Zip Code Response Code  Response Text
 * 8320  A  Address Match
 * 85284 Z  Zip Match
 * 8320<space> 85284 Y  Exact Match
 * 99999 U  Ver Unavailable
 * 99998 G  Ver Unavailable
 * 999970001   B  Address Match
 * 999970002   C  Serv Unavailable
 * 999970003   D  Exact Match
 * 999970004   I  Ver Unavailable
 * 999970005   M  Exact Match
 * 999970006   P  Zip Match
 * 999970007   A  Address Match
 * 999970008   Y  Exact Match
 * 999970009   S  Service Not Supported
 * 999970010   R  Issuer System Unavailable
 *
 * @author David I. Lehn <dlehn@digitalbazaar.com>
 * @author Dave Longley
 */
var testData = {
  validCards: {
    Visa: '4111111111111111',
    MasterCard: '5499740000000057',
    Discover: '6011000991001201',
    Amex: '371449635392376',
    Diners: '38555565010005',
    DinersMC: '36050000000003',
    JCB: '3530142019955809'
  },
  errorAmounts: {
    '0.00': {code: 13, msg: 'Invalid amount'},
    '0.69': {code: 51, msg: 'Insufficient funds'},
    '0.95': {code: 5, msg: 'Do not honor'}
  },
  validAmounts: {
    '1.42': '0142',
    '10.00': '0',
    '10.42': '01042',
    '32.49': 'A'
  },
  cvv2: {
    Visa: {
      '000': 'N',
      '999': 'M',
      '899': 'U',
      '799': 'P',
      '699': 'S'
    },
    MasterCard: {
      '000': 'N',
      '998': 'M',
      '898': 'U',
      '798': 'P',
      '698': 'S'
    },
    Discover: {
      '000': 'N',
      '996': 'M',
      '896': 'U',
      '796': 'P',
      '696': 'S'
    }
  },
  avs: {
    '00000': 'N',
    '24060': 'M',
    '24060-6345': 'M',
    '24061': '',
    '8320': 'A',
    '85284': 'Z',
    '8320 85284': 'Y',
    '99999': 'U',
    '99998': 'G',
    '999970001': 'B',
    '999970002': 'C',
    '999970003': 'D',
    '999970004': 'I',
    '999970005': 'M',
    '999970006': 'P',
    '999970007': 'A',
    '999970008': 'Y',
    '999970009': 'S',
    '999970010': 'R'
  }
};

/**
 * Initializes this module.
 *
 * @param callback(err) called once the operation completes.
 */
api.init = function(callback) {
  callback(null);
};

/**
 * Attempts to create a payment token. This may result in a hold on funds
 * for a customer, but it *must not* result in a capture of those funds. If
 * tokenization is not supported, then the callback will return a null
 * token.
 *
 * @param source the source of funds (eg: CreditCard, BankAccount).
 * @param token the PaymentToken with custom information to store.
 * @param callback(err, token) called once the operation completes.
 */
api.createPaymentToken = function(source, token, callback) {
  async.auto({
    hashSource: function(callback) {
      payswarm.tools.getTokenHash(source, callback);
    },
    blindSource: function(callback) {
      if(jsonld.hasValue(source, 'type', 'CreditCard')) {
        return callback(null, payswarm.tools.blindCreditCard(source));
      }
      if(jsonld.hasValue(source, 'type', 'BankAccount')) {
        return callback(null, payswarm.tools.blindBankAccount(source));
      }
      callback(null, bedrock.util.clone(source));
    }
  }, function(err, results) {
    if(err) {
      return callback(err);
    }
    var blinded = results.blindSource;
    token.paymentToken = results.hashSource;
    token.paymentGateway = api.gatewayName;
    token.paymentMethod = blinded.type;
    token.sysTokenHash = results.hashSource;
    if(!('sysVerified' in token) ||
      token.owner !== bedrock.config.authority.id) {
      token.sysVerified = (token.paymentMethod === 'CreditCard');
    }
    token.sysVerifyReady = token.sysVerified;
    if(jsonld.hasValue(source, 'type', 'CreditCard')) {
      token.cardBrand = blinded.cardBrand;
      token.cardNumber = blinded.cardNumber;
      token.cardExpMonth = blinded.cardExpMonth;
      token.cardExpYear = blinded.cardExpYear;
    } else if(jsonld.hasValue(source, 'type', 'BankAccount')) {
      token.bankAccount = blinded.bankAccount;
      token.bankRoutingNumber = blinded.bankRoutingNumber;
    }
    callback(null, token);
  });
};

/**
 * Charges a customer's payment source for a Deposit. A customer's payment
 * source may be approved even if there are some errors, like all AVS (address
 * verification service) checks did not pass, e.g. their zip and/or their
 * address was incorrect. This information will be returned in the result.
 *
 * If the payment source was not approved, an error will be returned.
 *
 * @param deposit the Deposit with a payment source, e.g. a PaymentToken.
 * @param callback(err, result) called once the operation completes.
 */
api.chargeDepositSource = function(deposit, callback) {
  payswarm.logger.debug(api.name + ', charging deposit source...', deposit);

  // clear any existing errors, initialize
  var result = {
    approved: false,
    errors: []
  };

  var source = deposit.source;
  async.waterfall([
    function(callback) {
      // check expiration
      if('cardExpYear' in source && 'cardExpMonth' in source) {
        var ccard = source;
        var expires = new Date(ccard.cardExpYear, ccard.cardExpMonth);
        var now = new Date();
        if(now >= expires) {
          result.errors.push('declined');
          return callback(new BedrockError(
            'Could not charge Deposit payment source; the payment gateway ' +
            'declined the payment source.',
            MODULE_TYPE + '.Declined', {result: result}));
        }
      }
      if(jsonld.hasValue(source, 'type', 'PaymentToken')) {
        result.approved = true;
        deposit.sysGatewayApprovalCode = 'Approved';
        deposit.sysGatewayOperation = 'charge';
        return callback();
      }
      if(jsonld.hasValue(source, 'type', 'BankAccount')) {
        result.approved = true;
        deposit.sysGatewayApprovalCode = 'Approved';
        deposit.sysGatewayOperation = 'charge';
        return callback();
      }
      if(jsonld.hasValue(source, 'type', 'CreditCard')) {
        // create simulated response from gateway
        return _createResponse(deposit, function(err, response) {
          if(err) {
            result.errors.push('unprocessed');
            return callback(err);
          }
          payswarm.logger.debug(api.name + ', gateway charge result',
            {response: response, deposit: deposit});
          _parseResponse(response, result, function(err) {
            if(!err && result.approved) {
              // if approved, then add auth approval code for receipt logs
              deposit.sysGatewayApprovalCode = response.Auth;
              deposit.sysGatewayOperation = 'charge';
            }
            callback(err);
          });
        });
      }
      result.errors.push('unprocessed');
      return callback(new BedrockError(
        'Could not charge Deposit; unsupported source of funds.',
        MODULE_TYPE + '.UnsupportedSource'));
    }
  ], function(err) {
    payswarm.logger.debug(api.name + ', ' +
      'gateway approved="' + result.approved + '"', result);

    if(result.approved &&
      (jsonld.hasValue(source, 'type', 'BankAccount') ||
      jsonld.hasValue(source, 'paymentMethod', 'BankAccount')) &&
      !jsonld.hasValue(source, 'owner', bedrock.config.authority.id)) {
      // set bank account settlement
      deposit.sysSettleAfter = (+new Date() +
        bedrock.config.financial.paymentGateway.Test.bankAccountSettlement);
    }
    callback(err, result);
  });
};

/**
 * Places funds from a customer's payment source on hold for a Deposit. A
 * customer's payment source may be approved even if there are some errors,
 * like all AVS (address verification service) checks did not pass, e.g. their
 * zip and/or their address was incorrect. This information will be returned in
 * the result.
 *
 * If a hold on the funds from the payment source was not approved, an error
 * will be returned.
 *
 * @param deposit the Deposit with a payment source, e.g. a PaymentToken.
 * @param callback(err, result) called once the operation completes.
 */
api.holdDepositFunds = function(deposit, callback) {
  payswarm.logger.debug(
    api.name + ', placing deposit source funds on hold...', deposit);

  // clear any existing errors, initialize
  var result = {
    approved: false,
    errors: []
  };

  var source = deposit.source;
  async.waterfall([
    function(callback) {
      // check expiration
      if('cardExpYear' in source && 'cardExpMonth' in source) {
        var ccard = source;
        var expires = new Date(ccard.cardExpYear, ccard.cardExpMonth);
        var now = new Date();
        if(now >= expires) {
          result.errors.push('declined');
          return callback(new BedrockError(
            'Could not hold Deposit funds; the payment gateway ' +
            'declined the payment source.',
            MODULE_TYPE + '.Declined', {result: result}));
        }
      }
      if(jsonld.hasValue(source, 'type', 'PaymentToken') &&
        !jsonld.hasValue(source, 'paymentMethod', 'BankAccount')) {
        result.approved = true;
        deposit.sysGatewayApprovalCode = 'Approved';
        deposit.sysGatewayOperation = 'hold';
        return callback();
      }
      if(jsonld.hasValue(source, 'type', 'CreditCard')) {
        // create simulated response from gateway
        return _createResponse(deposit, function(err, response) {
          if(err) {
            result.errors.push('unprocessed');
            return callback(err);
          }
          payswarm.logger.debug(api.name + ', gateway hold result',
            {response: response, deposit: deposit});
          _parseResponse(response, result, function(err) {
            if(!err && result.approved) {
              // if approved, then add auth approval code for receipt logs
              deposit.sysGatewayApprovalCode = response.Auth;
              deposit.sysGatewayOperation = 'hold';
            }
            callback(err);
          });
        });
      }
      result.errors.push('unprocessed');
      return callback(new BedrockError(
        'Could not place Deposit payment source funds on hold; ' +
        'unsupported source of funds.', MODULE_TYPE + '.UnsupportedSource'));
    }
  ], function(err) {
    payswarm.logger.debug(api.name + ', ' +
      'gateway approved="' + result.approved + '"', result);
    callback(err, result);
  });
};

/**
 * Captures funds from a customer's payment source for a Deposit that were
 * previously placed on hold. A customer's payment source may be approved even
 * if there are some errors, like all AVS (address verification service) checks
 * did not pass, e.g. their zip and/or their address was incorrect. This
 * information will be returned in the result.
 *
 * If the capture was not approved, an error will be returned.
 *
 * @param deposit the Deposit with a previously set sysGatewayRefId.
 * @param options the options to use.
 *          amount the amount to capture (can be different from the deposit
 *            total amount).
 * @param callback(err, result) called once the operation completes.
 */
api.captureDepositFunds = function(deposit, options, callback) {
  payswarm.logger.debug(
    api.name + ', capturing funds previously held from deposit source...',
    deposit);

  if(typeof options === 'function') {
    callback = options;
    options = null;
  }
  options = options || {};

  // clear any existing errors, initialize
  var result = {
    approved: false,
    errors: []
  };

  var source = deposit.source;
  async.waterfall([
    function(callback) {
      // check expiration
      if('cardExpYear' in source && 'cardExpMonth' in source) {
        var ccard = source;
        var expires = new Date(ccard.cardExpYear, ccard.cardExpMonth);
        var now = new Date();
        if(now >= expires) {
          result.errors.push('declined');
          return callback(new BedrockError(
            'Could not capture Deposit funds; the payment gateway ' +
            'declined the payment source.',
            MODULE_TYPE + '.Declined', {result: result}));
        }
      }
      if(jsonld.hasValue(source, 'type', 'PaymentToken') &&
        !jsonld.hasValue(source, 'paymentMethod', 'BankAccount')) {
        result.approved = true;
        deposit.sysGatewayApprovalCode = 'Approved';
        deposit.sysGatewayOperation = 'capture';
        return callback();
      }
      if(jsonld.hasValue(source, 'type', 'CreditCard')) {
        // create simulated response from gateway
        return _createResponse(deposit, function(err, response) {
          if(err) {
            result.errors.push('unprocessed');
            return callback(err);
          }
          payswarm.logger.debug(api.name + ', gateway capture result',
            {response: response, deposit: deposit});
          _parseResponse(response, result, function(err) {
            if(!err && result.approved) {
              // if approved, then add auth approval code for receipt logs
              deposit.sysGatewayApprovalCode = response.Auth;
              deposit.sysGatewayOperation = 'capture';
            }
            callback(err);
          });
        });
      }
      result.errors.push('unprocessed');
      return callback(new BedrockError(
        'Could not capture Deposit; unsupported source of funds.',
        MODULE_TYPE + '.UnsupportedSource'));
    }
  ], function(err) {
    payswarm.logger.debug(api.name + ', ' +
      'gateway approved="' + result.approved + '"', result);
    callback(err, result);
  });
};

/**
 * Credits a customer's payment destination for a Withdrawal.
 *
 * If the payment destination was not approved, an error will be returned.
 *
 * @param withdrawal the Withdrawal with a payment destination, e.g. a
 *          PaymentToken.
 * @param amount the amount to withdraw into the external destination (can
 *          be different from the withdrawal total amount).
 * @param callback(err, result) called once the operation completes.
 */
api.creditWithdrawalDestination = function(withdrawal, amount, callback) {
  payswarm.logger.debug(
    api.name + ', crediting withdrawal destination...',
    {withdrawal: withdrawal, amount: amount.toString()});

  // ensure amount uses external money
  amount = payswarm.money.createStingyMoney(amount).toString();

  // clear any existing errors, initialize
  var result = {
    approved: false,
    errors: []
  };

  var destination = withdrawal.destination;
  async.waterfall([
    function(callback) {
      if(jsonld.hasValue(destination, 'type', 'PaymentToken')) {
        result.approved = true;
        withdrawal.sysGatewayApprovalCode = 'Approved';
        withdrawal.sysGatewayOperation = 'credit';
        return callback();
      }
      if(jsonld.hasValue(destination, 'type', 'BankAccount')) {
        result.approved = true;
        withdrawal.sysGatewayApprovalCode = 'Approved';
        withdrawal.sysGatewayOperation = 'credit';
        return callback();
      }
      result.errors.push('unprocessed');
      return callback(new BedrockError(
        'Could not process Withdrawal; unsupported destination for funds.',
        MODULE_TYPE + '.UnsupportedDestination'));
    }
  ], function(err) {
    payswarm.logger.debug(api.name + ', ' +
      'gateway approved="' + result.approved + '"', result);

    if(result.approved &&
      (jsonld.hasValue(destination, 'type', 'BankAccount') ||
      jsonld.hasValue(destination, 'paymentMethod', 'BankAccount')) &&
      !jsonld.hasValue(destination, 'owner', bedrock.config.authority.id)) {
      // set bank account settlement
      withdrawal.sysSettleAfter = (+new Date() +
        bedrock.config.financial.paymentGateway.Test.bankAccountSettlement);
    }
    callback(err, result);
  });
};

/**
 * Gets the external status of a Transaction. If the Transaction is a Deposit
 * or a Withdrawal, an inquiry will be sent to the payment gateway to
 * determine its state.
 *
 * @param txn the Transaction to inquire about.
 * @param callback(err, result) called once the operation completes.
 */
api.getTransactionStatus = function(txn, callback) {
  payswarm.logger.debug(api.name + ', inquiring about transaction...', txn);

  var isDeposit = jsonld.hasValue(txn, 'type', 'Deposit');
  var isWithdrawal = jsonld.hasValue(txn, 'type', 'Withdrawal');
  if(!(isDeposit || isWithdrawal)) {
    // always consider non-deposit/non-withdrawals to be externally settled
    return callback(null, {status: 'settled'});
  }

  if(isDeposit) {
    // funds held, must be captured
    var held = jsonld.hasValue(txn, 'sysGatewayOperation', 'hold');
    if(held) {
      // do capture
      return api.captureDepositFunds(txn, function(err, res) {
        var result = {
          status: 'settled',
          response: res,
          errors: [],
          settleAfterIncrement: bedrock.config.financial.paymentGateway.Test
            .creditCardStatusSettleAfterIncrement
        };

        if(err) {
          result.status = 'error';
          result.errors.push(err);
        }

        callback(null, result);
      });
    }

    // always consider card deposits without approved 'hold' and
    // deposits from the authority to be externally settled
    var src = txn.source;
    if(jsonld.hasValue(src, 'paymentMethod', 'CreditCard') ||
      jsonld.hasValue(src, 'type', 'CreditCard') ||
      jsonld.hasValue(src, 'owner', bedrock.config.authority.id)) {
      return callback(null, {status: 'settled'});
    }
  }

  var settleAfter = txn.sysSettleAfter;
  // simulate delay in settlement on first check
  if(txn.sysExternalStatusChecks > 0 && +new Date() >= settleAfter) {
    return callback(null, {status: 'settled'});
  }

  // consider external txn pending
  callback(null, {
    status: 'pending',
    settleAfterIncrement: bedrock.config.financial.paymentGateway.Test
      .bankAccountStatusSettleAfterIncrement
  });
};

/**
 * Adds Payees for this gateway to the given Deposit.
 *
 * @param deposit the Deposit to add Payees to.
 * @param callback(err, deposit) called once the operation completes.
 */
api.addDepositPayees = function(deposit, callback) {
  var cfg = bedrock.config.financial.paymentGateway.Test.payees.deposit;
  var src = deposit.source;
  if(src.paymentMethod in cfg) {
    var methodCfg = cfg[src.paymentMethod];
    if(src.paymentMethod === 'CreditCard') {
      if(src.cardBrand in methodCfg) {
        jsonld.addValue(deposit, 'payee', methodCfg[src.cardBrand]);
      } else {
        jsonld.addValue(deposit, 'payee', methodCfg['default']);
      }
    } else {
      jsonld.addValue(deposit, 'payee', methodCfg);
    }
  }
  callback(null, deposit);
};

/**
 * Adds Payees for this gateway to the given Withdrawal.
 *
 * @param withdrawal the Withdrawal to add Payees to.
 * @param callback(err, withdrawal) called once the operation completes.
 */
api.addWithdrawalPayees = function(withdrawal, callback) {
  var cfg = bedrock.config.financial.paymentGateway.Test.payees.withdrawal;
  var dst = withdrawal.destination;
  if(dst.paymentMethod in cfg) {
    jsonld.addValue(withdrawal, 'payee', cfg[dst.paymentMethod]);
  }
  callback(null, withdrawal);
};

/**
 * Adjusts Transfers in the given Deposit for this gateway based on
 * the currency precision supported. This should be called immediately after
 * Transfer creation and is typically used to ensure that Transfer amounts or
 * the final Deposit amount has been appropriately rounded to account for
 * currency precision limitations.
 *
 * @param deposit the Deposit to check/modify.
 * @param callback(null, deposit) called once the operation completes.
 */
api.adjustDepositPrecision = function(deposit, callback) {
  // get rounded total by rounding each transfer based on gateway's precision;
  // rounding up to ensure sufficient funds are pulled
  var roundedTotal = payswarm.money.createGenerousMoney();
  var transfers = jsonld.getValues(deposit, 'transfer');
  for(var i = 0; i < transfers.length; ++i) {
    var transfer = transfers[i];
    var amount = payswarm.money.createGenerousMoney(transfer.amount);
    roundedTotal = roundedTotal.add(amount);
  }

  // add currency rounding transfer if rounded total > total
  var total = new Money(deposit.amount);
  if(roundedTotal.compareTo(total) > 0) {
    var roundingAccount = bedrock.config.financial.paymentGateway.Test
      .roundingAdjustmentAccount;
    jsonld.addValue(deposit, 'transfer', {
      type: 'Transfer',
      source: deposit.source.id,
      destination: roundingAccount,
      amount: new Money(roundedTotal).subtract(total).toString(),
      currency: deposit.currency,
      comment: 'Currency precision rounding adjustment'
    });
  }

  // set new rounded total
  deposit.amount = new Money(roundedTotal).toString();
  callback(null, deposit);
};

/**
 * Adjusts Transfers in the given Withdrawal for this gateway based on
 * the currency precision supported. This should be called immediately after
 * Transfer creation and is typically used to ensure that Transfer amounts or
 * the final Withdrawal amount has been appropriately rounded to account for
 * currency precision limitations.
 *
 * @param withdrawal the Withdrawal to check/modify.
 * @param callback(null, withdrawal) called once the operation completes.
 */
api.adjustWithdrawalPrecision = function(withdrawal, callback) {
  // get rounding error by rounding each transfer that isn't to the
  // withdrawal destinatino based on the gateway's precision;
  // rounding up to ensure sufficient funds are pulled
  var total = Money.ZERO;
  var roundingError = Money.ZERO;
  var transfers = jsonld.getValues(withdrawal, 'transfer');
  var externalTransfer = null;
  for(var i = 0; i < transfers.length; ++i) {
    var transfer = transfers[i];
    var amount = new Money(transfer.amount);
    if(transfer.destination === withdrawal.destination.id) {
      // save external transfer (assume only one)
      externalTransfer = transfer;
      continue;
    }

    // be generous; amount collected must be sufficient for fees
    var min = payswarm.money.createGenerousMoney(transfer.amount);
    roundingError = roundingError.add(new Money(min).subtract(amount));
    total = total.add(transfer.amount);
  }

  // remove rounding error from the external transfer
  var amount = new Money(externalTransfer.amount);
  if(!roundingError.isZero()) {
    amount = amount.subtract(roundingError);
  }

  // round withdrawal amount to gateway's precision;
  // be stingy as it can't be more than the requested amount
  var max = payswarm.money.createStingyMoney(amount);
  roundingError = roundingError.add(amount.subtract(max));
  // set new rounded amount and add to the total
  externalTransfer.amount = new Money(max).toString();
  total = total.add(externalTransfer.amount);

  // add currency rounding transfer if roundingError is not zero
  if(!roundingError.isZero()) {
    var roundingAccount = bedrock.config.financial.paymentGateway.Test
      .roundingAdjustmentAccount;
    jsonld.addValue(withdrawal, 'transfer', {
      type: 'Transfer',
      source: withdrawal.source,
      destination: roundingAccount,
      amount: roundingError.toString(),
      currency: withdrawal.currency,
      comment: 'Currency precision rounding adjustment'
    });
    // add rounding error to total
    total = total.add(roundingError);
  }

  // set new total
  withdrawal.amount = total.toString();
  callback(null, withdrawal);
};

/**
 * Blinds confidential information in a customer's deposit/payment source.
 *
 * @param deposit the Deposit with a payment source, e.g. CreditCard, to
 *          blind.
 * @param callback(err, blinded) called once the operation completes.
 */
api.blindDeposit = function(deposit, callback) {
  callback(null, deposit);
};

/**
 * Blinds confidential information in a customer's withdrawal/payment
 * destination.
 *
 * @param withdrawal the Withdrawal with a payment destination, e.g.
 *          BankAccount, to blind.
 * @param callback(err, blinded) called once the operation completes.
 */
api.blindWithdrawal = function(withdrawal, callback) {
  callback(null, withdrawal);
};

/**
 * Creates a fake card gateway response.
 *
 * @param deposit the deposit to create a fake response for.
 * @param callback(err, response) called once the operation completes.
 */
function _createResponse(deposit, callback) {
  var response = {};

  // get amount from first transfer (code assumes this is the amount to
  // be deposited into the identity's account)
  var transfers = jsonld.getValues(deposit.transfer);
  var amount = transfers[0].amount;

  // get key to test data as 2 digit precision amount
  var key = new Money(amount, 2, Up).toString();
  if(testData.errorAmounts[key]) {
    response.Auth = 'Declined';
  } else if(testData.validAmounts[key]) {
    response.Auth = testData.validAmounts[key];
  } else {
    // any amount is approved if not in the error amounts list
    response.Auth = 'Approved';
  }

  // check source
  var source = deposit.source;
  if(jsonld.hasValue(source, 'type', 'CreditCard')) {
    var address = source.address;

    // check card number
    var brand = source.cardBrand;
    if(testData.validCards[brand] !== source.cardNumber) {
      // invalid card number
      response.Auth = 'Declined';
    } else {
      // get cvv2 response
      var cvv2 = source.cardCvm;
      if(testData.cvv2[brand][cvv2]) {
        response.CVV2ResponseMsg = testData.cvv2[brand][cvv2];
      } else {
        // approve any other cvv2 as a match
        response.CVV2ResponseMsg = 'M';
      }

      // get AVS response
      var zip = address.postalCode;
      if(testData.avs[zip]) {
        response.AVSCode = testData.avs[zip];
      } else {
        // approve any other zip as a match
        response.AVSCode = 'M';
      }
    }
    return callback(null, response);
  }
  if(jsonld.hasValue(source, 'type', 'PaymentToken')) {
    // approved
    response.CVV2ResponseMsg = 'M';
    response.AVSCode = 'M';
    return callback(null, response);
  }

  // invalid source
  response.Auth = 'Declined';
  callback(null, response);
}

/**
 * Parses a response from the gateway.
 *
 * @param response the response data.
 * @param result the result to update.
 * @param callback(err) called once the operation completes.
 */
function _parseResponse(response, result, callback) {
  // fields in the response:
  //
  // TransID : a number, assigned by TransFirst
  // RefNo   : should be our TransactionId
  // Auth    : 10 chars, authentication code from gateway, either
  //           "Approved", auth code, "Declined",
  //           OR blank/NULL (same as "Declined")
  // Notes   : text, a description of failures
  // AVSCode : 2 chars, AVS Response Code, only first char is used for now
  // CVV2ResponseMsg : 1 char, CVV2 Response Code

  // parse Auth code
  if(response.Auth === 0 || response.Auth === 'declined') {
    result.errors.push('declined');
    return callback(new BedrockError(
      'The payment gateway declined the payment source.',
      MODULE_TYPE + '.Declined', {result: result}));
  }

  // card action was approved (money *was* withheld or authorization
  // *was* approved externally ... even if our checks on CVV2 or AVS fail)
  // Note: We actually set this approved to false for this TestGateway
  // if the CVV2 fails ... which is different from most production gateways
  // because the card will be declined outright if the CVV2 fails.
  result.approved = true;

  // Note: Apparently if the CVV2 doesn't pass on TransFirst, then
  // declined will be returned... which means that perhaps the code
  // to check the CVV2 response doesn't even need to be here, the
  // AVS code, however, if not a "match" will not result in declined
  // being returned, so we definitely must check it

  // check cvv2 code
  var cvv2 = response.CVV2ResponseMsg || '';
  cvv2 = cvv2.toUpperCase();
  switch(cvv2) {
  case 'M': // CVV2 Match
  case 'P': // Not Processed
  case 'U': // Service not available
  case 'S': // Service not supported
  case 'X': // No Response
    // not an error
    break;
  case 'N': // CVV2 No Match, epic fail
  case '':  // wrong CVV2 number/format or no CVV2 number
    result.approved = false;
    result.errors.push('invalidCvm');
    break;
  default: // Invalid CVV2 response code
    result.approved = false;
    result.errors.push('error');
    return callback(new BedrockError(
      'Invalid CVV2 response code.',
      MODULE_TYPE + '.InvalidCVV2ResponseCode',
      {'CVV2ResponseCode': cvv2}));
  }

  // check avs code
  var avs = response.AVSCode || '';
  avs = avs.toUpperCase();
  switch(avs) {
  case 'X': // Match, street and 9-digit zip both match
  case 'D': // INTERNATIONAL 'X'
  case 'F': // UK-SPECIFIC 'X'
  case 'Y': // Match, street and 5-digit zip both match
  case 'M': // INTERNATIONAL 'Y'
  case 'B': // INTERNATIONAL 'A', country may not have ZIP, so accept
  case 'U': // AVS not applicable or unavailable
  case 'R': // AVS not applicable or unavailable
  case 'S': // AVS service not supported by bank
  case 'I': // INTERNATIONAL 'U'
  case 'G': // GLOBAL AVS service unavailable
    // not an error
    break;
  case 'A': // Partial Match, street matches, neither zip does
    result.errors.push('invalidZip');
    break;
  case 'Z': // Partial Match, zip matches, address does not
  case 'P': // INTERNATIONAL 'Z'
  case 'W': // Partial Match, 9-digit zip matches, address does not
    result.errors.push('invalidAddress');
    break;
  case 'N': // No Match, nothing matches, epic fail
  case 'C': // INTERNATIONAL 'N'
    result.errors.push('invalidZip');
    result.errors.push('invalidAddress');
    break;
  case 'E': // not allowed for MOTO (Internet/Phone) transactions
    result.errors.push('error');
    break;
  // Invalid avs response code
  default:
    result.error.push('error');
    return callback(new BedrockError(
      'Invalid AVS response code.',
      MODULE_TYPE + '.InvalidAVSResponseCode',
      {'AVSResponseCode': avs}));
  }

  callback();
}
